pg = require('PhysicsGaming')
cp = require('chipmunk')

// From stochasm, via: http://home.online.no/~pjacklam/notes/invnorm/
function inverseNormalCumulativeDistribution(probability) {
  var high = probability > 0.97575,
    low = probability < 0.02425

  if (low || high) {
    var numCoefficients = [-7.784894002430293e-3, -3.223964580411365e-1, -2.400758277161838, -2.549732539343734, 4.374664141464968]
    var denomCoeffcients = [7.784695709041462e-3, 3.224671290700398e-1, 2.445134137142996, 3.754408661907416]
    var numMaxExponent = 5,
      denomMaxExponent = 4
    var coefficient = low ? 1 : -1
    var base = Math.sqrt(-2 * Math.log(low ? probability : 1 - probability))
  } else {
    var numCoefficients = [-3.969683028665376e1, 2.209460984245205e2, -2.759285104469687e2, 1.383577518672690e2, -3.066479806614716e1, 2.506628277459239]
    var denomCoeffcients = [-5.447609879822406e1, 1.615858368580409e2, -1.556989798598866e2, 6.680131188771972e1, -1.328068155288572e1]
    var numMaxExponent = 5,
      denomMaxExponent = 5
    var coefficient = probability - 0.5
    var base = Math.pow(coefficient, 2)
  }

  function mapMaxExp(maxExp) {
    return function(value, index) {
      return value * Math.pow(base, maxExp - index);
    }
  }

  var numerator = numCoefficients.map(mapMaxExp(numMaxExponent)).reduce(function(a, b) {
    return a + b
  }) //compute sum
  var denominator = denomCoeffcients.map(mapMaxExp(denomMaxExponent)).reduce(function(a, b) {
    return a + b
  }) + 1
  return coefficient * numerator / denominator;
}

// From https://stackoverflow.com/questions/5259421/cumulative-distribution-function-in-javascript
function normalcdf(mean, sigma, to) {
  var z = (to - mean) / Math.sqrt(2 * sigma * sigma);
  var t = 1 / (1 + 0.3275911 * Math.abs(z));
  var a1 = 0.254829592;
  var a2 = -0.284496736;
  var a3 = 1.421413741;
  var a4 = -1.453152027;
  var a5 = 1.061405429;
  var erf = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-z * z);
  var sign = 1;
  if (z < 0) {
    sign = -1;
  }
  return (1 / 2) * (1 + sign * erf);
}

function truncNorm(mu, sig, lower, upper) {
  mu = typeof(mu) === 'undefined' ? 0 : mu
  sig = typeof(sig) === 'undefined' ? 1 : sig
  var a = typeof(lower) === 'undefined' ? 0.000000000000001 : normalcdf(0, 1, (lower - mu) / sig)
  var b = typeof(upper) === 'undefined' ? 0.999999999999999 : normalcdf(0, 1, (upper - mu) / sig)
  var icdf = a + (b - a) * Math.random()
  var stdnorm = inverseNormalCumulativeDistribution(icdf)
  return mu + sig * stdnorm
}

function mod(a, b) {
  return ((a % b) + b) % b
}

function wrappedNorm(mu, sig) {
  mu = typeof(mu) === 'undefined' ? 0 : mu
  sig = typeof(sig) === 'undefined' ? 1 : sig
  stdnorm = inverseNormalCumulativeDistribution(Math.random())
  return (mod(mu + sig * stdnorm, 2 * Math.PI))
}

function Norm(mu, sig) {
  mu = typeof(mu) === 'undefined' ? 0 : mu
  sig = typeof(sig) === 'undefined' ? 1 : sig
  return mu + sig * inverseNormalCumulativeDistribution(Math.random())
}

// Easy wrapper for sleep/wake
function sleep(space, body) {
  if (space.bodies.indexOf(body) !== -1) space.deactivateBody(body)
}

function wake(space, body) {
  if (space.bodies.indexOf(body) === -1) space.activateBody(body)
}

// Not exposed in the javascript so we need to fake ContactPoints here
var ContactPoint = function(point, normal, dist) {
  this.point = point
  this.normal = normal
  this.dist = dist
}

function _addCollisions(s1, s2, collision_list) {
  var o1n = s1.name
  var o2n = s2.name
  if (o1n < o2n) {
    var tmp = o1n
    o1n = o2n
    o2n = tmp
  }
  matched = false
  for (var i = 0; i < collision_list.length; i++) {
    var c = collision_list[i]
    if (c[0] === o1n && c[1] === o2n) {
      matched = true
    }
  }
  if (!matched) collision_list.push([o1n, o2n])
  return collision_list
}

function _moveStatic(obj, pos_ch, space) {
  fric = obj.friction
  elast = obj.elasticity
  nm = obj.name

  // Handle each type separately by destroying and recreating
  if (obj.type === 'Poly') {
    space.removeShape(obj.cpShape)
    var nverts = []
    var overts = obj.getVertices()
    for (var i = 0; i < overts.length; i++) {
      nverts.push(overts[i][0] + pos_ch[0], overts[i][1] + pos_ch[1])
    }
    obj.cpShape = new cp.PolyShape(space.staticBody, nverts, cp.vzero)
    obj.cpShape.setFriction(fric)
    obj.cpShape.setElasticity(elast)
    obj.cpShape.setCollisionType(pg.coltype_solid)
    obj.cpShape.name = nm
    space.addShape(obj.cpShape)
  } else if (obj.type === 'Ball') {
    var opos = obj.getPos()
    var npos = [opos[0] + pos_ch[0], opos[1] + pos_ch[1]]
    rad = obj.getRadius()
    space.removeShape(obj.cpShape)
    obj.cpShape = new cp.CircleShape(space.staticBody, rad, npos)
    obj.cpShape.setFriction(fric)
    obj.cpShape.setElasticity(elast)
    obj.cpShape.setCollisionType(pg.coltype_solid)
    obj.cpShape.name = nm
    space.addShape(obj.cpShape)
  } else if (obj.type === 'Segment') {
    var pts = obj.getPoints()
    var a = [pts[0][0] + pos_ch[0], pts[0][1] + pos_ch[1]]
    var b = [pts[1][0] + pos_ch[0], pts[1][1] + pos_ch[1]]
    var rad = obj.cpShape.r
    space.removeShape(obj.cpShape)
    obj.cpShape = new cp.SegmentShape(space.staticBody, a, b, rad)
    obj.cpShape.setFriction(fric)
    obj.cpShape.setElasticity(elast)
    obj.cpShape.setCollisionType(pg.coltype_solid)
    obj.cpShape.name = nm
    space.addShape(obj.cpShape)
  } else if (obj.type === 'Container') {
    for (var i = 0; i < obj.cpPolyShapes.length; i++) {
      space.removeShape(obj.cpPolyShapes[i])
    }
    space.removeShape(obj.cpSensor)
    var newshapes = []
    var newpolys = []
    var seglist = []
    debugger
    for (var i = 0; i < obj.seglist.length; i++) {
      var s = obj.seglist[i]
      seglist.push(new cp.v(s.x + pos_ch[0], s.y + pos_ch[1]))
    }
    obj.seglist = seglist
    var polys = obj.getPolys()
    for (var i = 0; i < polys.length; i++) {
      var p = polys[i]
      var newverts = []
      for (var j = 0; j < p.length; j++) {
        var v = p[j]
        newverts.push(v[0] + pos_ch[0], v[1] + pos_ch[1])
      }
      newpolys.push(newverts)
      var s = new cp.PolyShape(space.staticBody, newverts, cp.vzero)
      s.setFriction(fric)
      s.setElasticity(elast)
      s.setCollisionType(pg.coltype_solid)
      s.name = nm
      newshapes.push(s)
      space.addShape(s)
    }
    obj.polylist = newpolys
    obj.cpPolyShapes = newshapes
    var sensevert = []
    var nverts = obj.cpSensor.getNumVerts()
    var osensevert = []
    debugger
    for (var i = 0; i < nverts; i++) {
      osensevert.push(obj.cpSensor.getVert(i))
    }
    for (var i = 0; i < osensevert.length; i++) {
      var v = osensevert[i]
      sensevert.push(v.x + pos_ch[0], v.y + pos_ch[1])
    }
    obj.cpSensor = new cp.PolyShape(space.staticBody, sensevert, cp.vzero)
    obj.cpSensor.sensor = true
    obj.cpSensor.setCollisionType(pg.coltype_sensor)
    obj.cpSensor.name = nm
    space.addShape(obj.cpSensor)
  } else if (obj.type === 'Compound') {
    for (var i = 0; i < obj.cpShapes.length; i++) {
      space.removeShape(obj.cpShapes[i])
    }
    var newpolys = []
    var newshapes = []
    var oldpolys = obj.getPolys()
    for (var i = 0; i < oldpolys.length; i++) {
      var p = oldpolys[i]
      var newverts = []
      for (var j = 0; j < p.length; j++) {
        var v = p[j]
        newverts.push(v[0] + pos_ch[0], v[1] + pos_ch[1])
      }
      newpolys.append(newverts)
      var s = new cp.PolyShape(space.staticBody, newverts)
      s.setFriction(fric)
      s.setElasticity(elast)
      s.setCollisionType(pg.coltype_solid)
      s.name = nm
      newshapes.push(s)
      space.addShape(s)
    }
    obj.polylist = newpolys
    obj.cpShapes = newshapes
  }
}

/*
For more details see the python implementation pyGameWorld/noisyWorld.py

NOITE: noise_object things aren't yet implemented
 */
function noisifyWorld(gameworld, noise_position_static, noise_position_moving,
  noise_collision_direction, noise_collision_elasticity,
  noise_gravity, noise_object_friction,
  noise_object_density, noise_object_elasticity) {
  noise_position_static = typeof(noise_position_static) === 'undefined' ? 5. : noise_position_static
  noise_position_moving = typeof(noise_position_moving) === 'undefined' ? 5. : noise_position_moving
  noise_collision_direction = typeof(noise_collision_direction) === 'undefined' ? 2. : noise_collision_direction
  noise_collision_elasticity = typeof(noise_collision_elasticity) === 'undefined' ? 2. : noise_collision_elasticity
  noise_gravity = typeof(noise_gravity) === 'undefined' ? 1. : noise_gravity
  noise_object_friction = typeof(noise_object_friction) === 'undefined' ? 1. : noise_object_friction
  noise_object_density = typeof(noise_object_density) === 'undefined' ? 1. : noise_object_density
  noise_object_elasticity = typeof(noise_object_elasticity) === 'undefined' ? 1. : noise_object_elasticity

  var w = gameworld
  // Figure out gravity with adjustments
  var grav = w.getGravity() * (noise_gravity > 0 ? truncNorm(1, noise_gravity, 0) : 1)

  // Turn things off (gravity & callbacks)
  w.setGravity(0)
  for (var i=0; i<10; i++){w.step(.00001)}

  w.cpSpace.removeCollisionHandler(pg.coltype_solid, pg.coltype_solid)
  w.cpSpace.removeCollisionHandler(pg.coltype_placed, pg.coltype_solid)
  w.cpSpace.removeCollisionHandler(pg.coltype_solid, pg.coltype_sensor)
  w.cpSpace.removeCollisionHandler(pg.coltype_placed, pg.coltype_sensor)
  w.step(.0001)

  // Adjust object positions / attributes
  wall_names = ["_LeftWall", "_BottomWall", "_RightWall", "_TopWall"]
  var objs = Object.keys(w.objects)
  /*
  Adjust static objects
   */
  if (noise_position_static > 0) {
    // For some reason there must be moving noise (to reset objects?) if static stuff moves around
    noise_position_moving = (noise_position_moving === 0) ? .00001 : noise_position_moving
    // Make object groups
    var obj_groups = []
    for (var i = 0; i < (objs.length - 1); i++) {
      var o1 = w.objects[objs[i]]
      if (wall_names.indexOf(o1.name) === -1) {
        var this_idx = -1
        for (var idx = 0; idx < obj_groups.length; idx++) {
          og = obj_groups[idx]
          var ognames = og.map(function(o) {
            return o.name
          })
          if (ognames.indexOf(o1.name) != -1) {
            this_idx = idx
          }
        }
        if (this_idx === -1) {
          this_idx = obj_groups.length
          obj_groups.push([o1])
        }
        for (var j = i + 1; j < objs.length; j++) {
          var o2 = w.objects[objs[j]]
          if (o1.checkContact(o2)) {
            var thisognames = obj_groups[this_idx].map(function(o) {
              return o.name
            }).concat(wall_names)
            if (thisognames.indexOf(o2.name) === -1) obj_groups[this_idx].push(o2)
          }
        }
      }
    }
    // Now that space is segmented, move obj groups together
    for (var i = 0; i < obj_groups.length; i++) {
      var og = obj_groups[i]
      var pos_change = [noise_position_static * Norm(), noise_position_static * Norm()]
      for (var j = 0; j < og.length; j++) {
        var o = og[j]
        if (o.isStatic()) {
          _moveStatic(o, pos_change, w.cpSpace)
        } else {
          var p = o.getPos()
          o.setPos([p[0] + pos_change[0], p[1] + pos_change[1]])
        }
      }
    }
  }

  /*
  Move non-static while ensuring still touching
   */
  if (noise_position_moving > 0) {
    var free_obj = []
    var orig_pos = {}
    var orig_vel = {}
    var orig_rot = {}
    var touch_dict = {}
    for (var i = 0; i < objs.length; i++) {
      var onm = objs[i]
      var obj = w.objects[onm]
      if (!obj.isStatic()) {
        free_obj.push(obj)
        orig_pos[onm] = obj.getPos()
        orig_vel[onm] = obj.getVel()
        orig_rot[onm] = obj.getRot()
        obj.setVel([0, 0])
        touch_dict[onm] = []
        for (var j = 0; j < objs.length; j++) {
          var onm2 = objs[j]
          if (onm !== onm2) {
            obj2 = w.objects[onm2]
            if (obj.checkContact(obj2)) touch_dict[onm].push(obj2)
          }
        }
      }
    }
    // Catch to ensure moving static objects doesn't produce impossibility
    var noise_attempts = 0
    var max_attempts = 500
    while (free_obj.length > 0 && noise_attempts < max_attempts) {
      noise_attempts++
      for (var i = 0; i < free_obj.length; i++) {
        var o = free_obj[i]
        var pos = o.getPos()
        o.setPos([pos[0] + noise_position_moving * Norm(),
          pos[1] + noise_position_moving * Norm()
        ])
      }
      for (var i = 0; i < 10; i++) {
        w.cpSpace.step(.1)
      }
      // Do contacts still remain?
      var checked_contacts = []
      for (var i = 0; i < free_obj.length; i++) {
        var o = free_obj[i]
        var onm = o.name
        stillgood = true
        touches = touch_dict[onm]
        for (var j = 0; j < objs.length; j++) {
          var o2nm = objs[j]
          var o2 = w.objects[o2nm]
          if (stillgood && onm !== o2nm) {
            if (o.checkContact(o2)) {
              if (touches.indexOf(o2) === -1) {
                stillgood = false
              }
            } else {
              if (touches.indexOf(o2) !== -1) {
                stillgood = false
              }
            }
          }
        }
        if (stillgood) {
          checked_contacts.push(onm)
          sleep(w.cpSpace, o.cpBody)
          //w.cpSpace.deactivateBody(o.cpBody)
        } else {
          o.setPos(orig_pos[onm])
          o.setRot(orig_rot[onm])
        }
      }
      curr_free_obj = []
      for (var i = 0; i < free_obj.length; i++) {
        var o = free_obj[i]
        if (checked_contacts.indexOf(o.name) === -1) curr_free_obj.push(o)
      }
      if (curr_free_obj.length > 0) {
        for (var i = 0; i < free_obj.length; i++) {
          var o = free_obj[i]
          wake(w.cpSpace, o.cpBody)
        }
      } else {
        free_obj = []
      }
    }
    for (onm in orig_vel) {
      var v = orig_vel[onm]
      var o = w.objects[onm]
      wake(w.cpSpace, o.cpBody)
      //o.cpBody.activate()
      o.setVel(v)
    }
    if (noise_attempts >= max_attempts) {
      for (onm in orig_vel) {
        var v = orig_vel[onm]
        var o = w.objects[onm]
        o.setVel(v)
        o.setPos(orig_pos[onm])
        o.setRot(orig_rot[onm])
      }
    }
  }

  /* Noisify the densities, elasticities, fricionts
   */
  for (var i =0; i < objs.length; i++) {
    var o = w.objects[objs[i]]
    if (!o.isStatic()) {
      if (noise_object_density > 0) {
        var madj = truncNorm(1, noise_object_density, 0.0001)
        o.density = o.density * madj
        var omass = o.cpBody.m
        o.cpBody.setMass(omass*madj)
      }
      if (noise_object_friction > 0 || noise_object_elasticity > 0) {
        var fadj = noise_object_friction === 0 ? 1 : truncNorm(1, noise_object_friction, 0.0001)
        var eadj = noise_object_elasticity === 0 ? 1 : truncNorm(1, noise_object_elasticity, 0.0001)
        o.friction = o.friction * fadj
        o.elasticity = o.elasticity * eadj
        if (o.type == 'Container') {
          for (var j = 0; j < o.cpPolyShapes.length; j++) {
            var s = o.cpPolyShapes[j]
            s.setFriction(o.friction)
            s.setElasticity(o.elasticity)
          }
        } else if(o.type == 'Compound') {
          for (var j = 0; j < o.cpShapes.length; j++) {
            var s = o.cpShapes[j]
            s.setFriction(o.friction)
            s.setElasticity(o.elasticity)
          }
        } else {
          o.cpShape.setFriction(o.friction)
          o.cpShape.setElasticity(o.elasticity)
        }
      }
    }
  }

  /*
  Set callbacks to add noise
   */
  var ssbeg
  if (noise_collision_direction > 0 || noise_collision_elasticity > 0) {
    function noisifyArb(arb) {
      if (noise_collision_elasticity > 0) {
        arb.e += truncNorm(0, noise_collision_elasticity, -arb.e)
      }
      if (noise_collision_direction > 0) {
        var cps = arb.contacts
        //console.log(cps)
        for (var i = 0; i < cps.length; i++) {
          var contact = cps[i]
          //console.log(contact)
          var nrm = contact.n
          var rndwrp = wrappedNorm(0, noise_collision_direction)
          //console.log(rndwrp)
          var rndang = cp.v.forangle(rndwrp)
          //console.log(rndang)
          var newnorm = nrm.rotate(rndang)
          //console.log(newnorm)
          contact.n = newnorm
          //console.log(contact)
        }
        //console.log(arb.contacts)
        //debugger
      }
    }
    ssbeg = function(arb, space, pgworld) {
      noisifyArb(arb)
      pgworld._solidSolidPre(arb, space, pgworld)
      return true
    }
  } else {
    ssbeg = function(arb, space, pgworld) {
      pgworld._solidSolidPre(arb, space, pgworld)
      return true
    }
  }

  /*
  Reset the world
   */
  w.setGravity(grav)
  // Functions outside of the PGWorld object for callbacks
  function ssbeg(arb, space, pgworld) {
    pgworld._solidSolidBegin(arb, space, pgworld)
    return true
  }

  function sspre(arb, space, pgworld) {
    pgworld._solidSolidPre(arb, space, pgworld)
    return true
  }

  function sspost(arb, space, pgworld) {
    pgworld._solidSolidPost(arb, space, pgworld)
    return true
  }

  function ssend(arb, space, pgworld) {
    pgworld._solidSolidEnd(arb, space, pgworld)
    return true
  }

  function sgbeg(arb, space, pgworld) {
    pgworld._solidGoalBegin(arb, space, pgworld)
    return false
  }

  function sgend(arb, space, pgworld) {
    pgworld._solidGoalEnd(arb, space, pgworld)
    return false
  }
  w.cpSpace.addCollisionHandler(pg.coltype_solid, pg.coltype_solid,
    function(arb, space) {
      return ssbeg(arb, space, w)
    },
    function(arb, space) {
      return sspre(arb, space, w)
    },
    function(arb, space) {
      return sspost(arb, space, w)
    },
    function(arb, space) {
      return ssend(arb, space, w)
    })
  w.cpSpace.addCollisionHandler(pg.coltype_placed, pg.coltype_solid,
    function(arb, space) {
      return ssbeg(arb, space, w)
    },
    function(arb, space) {
      return sspre(arb, space, w)
    },
    function(arb, space) {
      return sspost(arb, space, w)
    },
    function(arb, space) {
      return ssend(arb, space, w)
    })
  w.cpSpace.addCollisionHandler(pg.coltype_solid, pg.coltype_sensor,
    function(arb, space) {
      return sgbeg(arb, space, w)
    },
    null,
    null,
    function(arb, space) {
      return sgend(arb, space, w)
    })
  w.cpSpace.addCollisionHandler(pg.coltype_placed, pg.coltype_sensor,
    function(arb, space) {
      return sgbeg(arb, space, w)
    },
    null,
    null,
    function(arb, space) {
      return sgend(arb, space, w)
    })

  w.cpSpace.step(.0001)
  return w
}

module.exports = {
  noisifyWorld: noisifyWorld
}
